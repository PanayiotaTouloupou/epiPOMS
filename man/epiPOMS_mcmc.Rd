% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/epiPOMS_mcmc.R
\name{epiPOMS_mcmc}
\alias{epiPOMS_mcmc}
\title{MCMC-based tool for analyzing partially observed multi-strain epidemic data.}
\usage{
epiPOMS_mcmc(infoepidata, mcmccontrol, priorcontrol, smallgroups,
  parallel = TRUE, ncores = min(infoepidata$ngroups, getOption("cl.cores",
  detectCores())))
}
\arguments{
\item{infoepidata}{A list containing the right format and general information of
an object of class \sQuote{epiPOMSdata}, obtained using function
\code{\link{info_epiPOMSdata}}.}

\item{mcmccontrol}{A list containing the parameter values that control the MCMC
algorithm, obtained using function \code{\link{mcmc_control}}.}

\item{priorcontrol}{A list containing the hyperparameters for the prior
distributions for the MCMC algorithm, obtained using function
\code{\link{prior_control}}.}

\item{smallgroups}{A vector of positive integers, with length equal to the number
of groups that are smaller in terms of area (in square meters), containing
the indices of the small groups. These values must be between 1 and the total
number of groups in the study. Set \code{smallgroups = NULL} if there is no
difference between groups.}

\item{parallel}{A logical value; if set to \code{TRUE}, the hidden carriage process
for each group is updated in parallel. If it is \code{FALSE}, then the
carriage processes are updated sequentially. The default is \code{TRUE}.
See details, below, for more information.}

\item{ncores}{A positive integer providing the number of required cores if
\code{parallel} is set to \code{TRUE}. This value must be between 1 and the
minimum of the total number of groups in the study and the number of available
cores on the user's computer. By default \code{ncores} is set to the minimum of
the number of groups and the number of available cores.}
}
\value{
An object of class \sQuote{epiPOMSmcmc} is returned containing the following:
\describe{
\item{alphamcmc}{A \eqn{sampsize} by \eqn{n_g} matrix containing the posterior
samples for the \eqn{\alpha} parameters, where \eqn{sampsize} denotes the
size of the thinned recorded MCMC samples after the burnin period and
\eqn{n_g} denotes the number of different strains in the study. The
\eqn{i^{th}}{ith} column contains the samples for the \eqn{i^{th}}{ith}
\eqn{\alpha} parameter. The first column corresponds to the
first strain, the second column to the second strain and so on.}
\item{betamcmc}{A \eqn{sampsize} by \eqn{n_g} matrix containing the posterior
samples for the \eqn{\beta} parameters. The \eqn{i^{th}}{ith} column contains
the samples for the \eqn{i^{th}}{ith} \eqn{\beta} parameter. The first column
corresponds to the first strain, the second column to the second strain and
so on.}
\item{mumcmc}{A \eqn{sampsize} by \eqn{n_g} matrix containing the posterior
samples for the \eqn{\mu} parameters. The \eqn{i^{th}}{ith} column contains
the samples for the \eqn{i^{th}}{ith} \eqn{\mu} parameter. The first column
corresponds to the first strain, the second column to the second strain and
so on.}
\item{deltamcmc}{A vector of length \eqn{sampsize} containing the posterior
samples for parameter \eqn{\delta}.}
\item{gammamcmc}{A vector of length \eqn{sampsize} containing the posterior
samples for parameter \eqn{\gamma}, if
\code{smallgroups} \eqn{\neq}{≠} \code{NULL}. Otherwise a \code{NULL} value
is returned.}
\item{numcmc}{A \eqn{sampsize} by \eqn{(n_g + 1)} matrix containing the
posterior samples for the \eqn{\nu} parameters. The \eqn{i^{th}}{ith} column
contains the samples for the \eqn{i^{th}}{ith} \eqn{\nu} parameter. The first
column corresponds to the non-carriage state. The second and subsequent
columns correspond to the carriage of one of the \eqn{n_g} strains.}
\item{thetamcmc}{A \eqn{sampsize} by \eqn{5} matrix containing the posterior
samples for the \eqn{\theta} parameters. The \eqn{i^{th}}{ith} column
contains the samples for the \eqn{i^{th}}{ith} \eqn{\theta} parameter.}
\item{probstates}{A list containing \eqn{P} arrays, one for each group, with
the posterior probability that an individual of a group is not colonised or
is colonised by a specific strain over the sampling period. The dimensions of
each array are \eqn{(n_g + 1)} by \eqn{C^{[p]}}{C^[p]} by \eqn{T^{[p]}}{T^[p]},
where \eqn{C^{[p]}}{C^[p]} and \eqn{T^{[p]}}{T^[p]} denote the total number of
individuals and the time of the last observation in group
\eqn{p = 1, 2, \ldots, P}, respectively.}
\item{sumstates}{A \eqn{sampsize} by \eqn{(n_g + 1)} matrix containing the
total number of individuals in the population having augmented state of
carriage equal to \eqn{s} over the entire study period, where
\eqn{s = 0, 1, \ldots, n_g}.}
\item{statetrans}{A \eqn{sampsize} by \eqn{5} matrix containing the total
number of state-specific transitions in the augmented carriage process of all
individuals. The \eqn{i^{th}}{ith} column contains the total number for the
\eqn{i^{th}}{ith} state-specific transition. The transitions are (in order):
from \eqn{r} to \eqn{s} where \eqn{r \neq s \neq 0}{r ≠ s ≠ 0}, from \eqn{0}
to \eqn{s} where \eqn{s \neq 0}{s ≠ 0}, from \eqn{r} to \eqn{0} where
\eqn{r \neq 0}{r ≠ 0}, from \eqn{0} to \eqn{0} and from \eqn{r} to \eqn{r}
where \eqn{r \neq 0}{r ≠ 0}.}
\item{stepsize}{A real value specifying the leapfrog stepsize used in HMC
method after the burnin period.}
}
}
\description{
Runs a Bayesian data augmented Markov chain Monte Carlo (MCMC) algorithm for
fitting partially observed multi-strain models to longitudinal epidemic data
with misclassification of a population of individuals which is divided into
groups.
}
\details{
Our approach to analyse partially observed longitudinal multi-strain epidemic
data, involves assuming that the classifications at an observation time are
imperfect measures of an underlying true (hidden) epidemic process. This
facilitates the use of partially observed epidemic models (\acronym{POMS}),
which provide a natural framework to analyse infection dynamics in
longitudinal studies where the observed data are subject to potential testing
error due to poor sensitivity of the diagnostic and strain procedure used.
For the full details see \insertCite{Touloupou2020;textual}{epiPOMS}.

Parameter estimation in \acronym{POMS} epidemic models is done by using MCMC
data augmentation methods, that employs both Gibbs and Hamiltonian Monte Carlo
(HMC) updates. More specifically, sampling the hidden carriage states of each
individual is done by using a Gibbs step via the individual-Forward
Filtering Backward Sampling (iFFBS) algorithm by
\insertCite{Touloupou2019;textual}{epiPOMS}. The initial probability
parameters, \eqn{\nu}, and the observation parameters, \eqn{\theta_1},
\eqn{\theta_2}, \eqn{\theta_C}, \eqn{\theta_S} and  \eqn{\theta_P}, are
updated using Gibbs updates. The remaining parameters are updated jointly
using an HMC algorithm. For a more precise description, see
\code{\link{iFFBS_upd}} and \code{\link{HMC_upd}}, and
\code{\link{prior_control}} for the prior specification of the parameters.

For faster run of the \code{\link{epiPOMS_mcmc}} function, the hidden
carriage process for each group can be updated in parallel, since we assume
that groups are independent of one another. This option is controlled via
the two arguments \code{parallel} and \code{ncores}. If  \code{parallel} is
set to \code{TRUE}  the number of required cores, \code{ncores}, should be
specified.
}
\examples{
# Simulate partially observed multi-strain epidemic data. Individuals in
# 15 different groups of size varied from 4 to 9, were tested at the same
# time points, every 3 days during a period of 100 days. Five strains
# were identified.
set.seed(1)
ntypes <- 5
ngroups <- 15
ninds <- sample(4:9, size = ngroups, replace = TRUE)
tmax <- rep(100, ngroups)
hidpars <- list(alpha = c(sample(c(0.0015, 0.001), ntypes - 1, replace = TRUE),
     0.002), beta = sample(c(0.005, 0.01), ntypes, replace = TRUE), mu =
     sample(c(0.1, 0.15), ntypes, replace = TRUE), delta = 0.5, gamma = 2,
     nu = c(0.9, rep((1-0.9)/(ntypes+1), (ntypes-1)), 2*(1-0.9)/(ntypes+1)))
obserpars <- c(0.8, 0.5, 0.8, 0.025, 0.05)
smallgroups <- sample(1:ngroups, size = 10)
obsertimes <- lapply(tmax, function(x) seq(1, x, 3))
indNA <- c(rep(0, ngroups-1), 1)
tNA <- c(rep(100, ngroups-1), 70)
npostyped <- 20
epidata <- obserdata_sim(ntypes = ntypes, ngroups = ngroups, ninds = ninds,
     tmax = tmax, hidpars = hidpars, obserpars = obserpars, smallgroups =
     smallgroups, obsertimes = obsertimes, indNA = indNA, tNA = tNA,
     npostyped = npostyped)

# Modify and extract information
infoepidata <- info_epiPOMSdata(epidata)

# Set hyperparameters for the prior distributions
priorcontrol <- prior_control(ntypes = ntypes)

# Set initial values for MCMC algorithm
initpars <- list(alpha = rep(0.01, infoepidata$ntypes), beta = rep(0.01,
     infoepidata$ntypes), mu = rep(0.01, infoepidata$ntypes), delta = 1,
     gamma = 1, nu =  c(0.9, rep(0.1/(infoepidata$ntypes),
     infoepidata$ntypes)), theta = c(0.5, 0.5, 0.9, 0.05, 0.5))
mcmcinitpars <- mcmc_initpars(inittype = "manual", initpars = initpars,
     epidata = epidata, smallgroups = smallgroups)

# Set control parameters for MCMC algorithm
mcmccontrol <- mcmc_control(nsamp = 50, burnin = 10, init_pars =
     mcmcinitpars, ntypes = ntypes)

# Run MCMC algorithm on the simulated epidemic
# Note: Not enough iterations for any real inference
# Note: This will take a few seconds to run
tic = Sys.time()
examplemcmc <- epiPOMS_mcmc(infoepidata = infoepidata, mcmccontrol =
     mcmccontrol, priorcontrol = priorcontrol, smallgroups = smallgroups,
     parallel = FALSE)
toc = Sys.time() - tic
toc

# Note: Not enough iterations for assessing convergence or mixing of chains
plot(x = examplemcmc, infoepidata = infoepidata)

\dontrun{
# Note: This will take a few minutes to run
# E. coli O157:H7 data analysis
# Load E. coli O157:H7 data
set.seed(50)
data(Ecoliepidata)
smallgroups <- c(6:10, 14:20)

# Format the data
epidata <- as_epiPOMSdata(Ecoliepidata)

# Modify and extract information
infoepidata <- info_epiPOMSdata(epidata)

# Set hyperparameters for the prior distributions
priorcontrol <- prior_control(ntypes = infoepidata$ntypes)

# Generate initial values for MCMC algorithm
mcmcinitpars <- mcmc_initpars(priorcontrol = priorcontrol, epidata =
     epidata, smallgroups = smallgroups)

# Set control parameters for MCMC algorithm
mcmccontrol <- mcmc_control(nsamp = 250, burnin = 50, init_pars =
     mcmcinitpars, ntypes = infoepidata$ntypes)

# Run MCMC algorithm on the E. coli O157:H7 data
# Note: Not enough iterations for any real inference
tic = Sys.time()
examplemcmc <- epiPOMS_mcmc(infoepidata = infoepidata, mcmccontrol =
     mcmccontrol, priorcontrol = priorcontrol, smallgroups = smallgroups,
     parallel = TRUE)
toc = Sys.time() - tic
toc
}

\dontrun{
# Note: This will take a few minutes to run
# E. coli O157:H7 data analysis using a simpler model where parameter delta
# is not included in the model
# Load E. coli O157:H7 data
set.seed(50)
data(Ecoliepidata)
smallgroups <- NULL # we assume no difference between small and big pens

# Format the data
epidata <- as_epiPOMSdata(Ecoliepidata)

# Modify and extract information
infoepidata <- info_epiPOMSdata(epidata)

# Set hyperparameters for the prior distributions
priorcontrol <- prior_control(ntypes = infoepidata$ntypes, gammaprior = NULL)

# Generate initial values for MCMC algorithm
mcmcinitpars <- mcmc_initpars(priorcontrol = priorcontrol, epidata =
     epidata, smallgroups = smallgroups)

# Set control parameters for MCMC algorithm
mcmccontrol <- mcmc_control(nsamp = 250, burnin = 50, init_pars =
     mcmcinitpars, ntypes = infoepidata$ntypes)

# Run MCMC algorithm on the E. coli O157:H7 data
# Note: Not enough iterations for any real inference
tic = Sys.time()
examplemcmc <- epiPOMS_mcmc(infoepidata = infoepidata, mcmccontrol =
     mcmccontrol, priorcontrol = priorcontrol, smallgroups = smallgroups,
     parallel = TRUE)
toc = Sys.time() - tic
toc
}

}
\references{
\insertAllCited{}
}
\seealso{
\code{\link{prior_control}} for specifying the hyperparameters of the prior
distributions, \code{\link{mcmc_control}} for setting the parameter values that
control the MCMC algorithm, \code{\link{info_epiPOMSdata}} for extracting
information of an object of class \sQuote{epiPOMSdata},
\code{\link{plot.epiPOMSmcmc}} and \code{\link{summary.epiPOMSmcmc}} for
plotting and displaying summary information of an \sQuote{epiPOMSmcmc}
object.
}
\author{
Panayiota Touloupou
}
