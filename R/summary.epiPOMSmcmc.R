#' Summarize posterior samples from \sQuote{epiPOMSmcmc} object.
#'
#' @description
#' The summary method of \sQuote{epiPOMSmcmc} objects (i.e. the output of the
#' \code{\link{epiPOMS_mcmc}} function) can be used to display and return four
#' sets of summary information. The summary includes highest posterior density
#' (HPD) intervals, quantiles and effective sample size (ESS) of the sample
#' distribution for each model parameter, as well as, the mean vector and the
#' covariance matrix of the posterior distribution of the parameters.
#'
#' @param
#' object An object of class \sQuote{epiPOMSmcmc}, produced from the
#' \code{\link{epiPOMS_mcmc}} function.
#' @param
#' HPDprob A numeric scalar in the interval (0,1), similar to that in
#' \code{HPDinterval} from the \code{coda} package, giving the target probability
#' content of the highest posterior density intervals. Defaults to 0.9.
#' @param
#' quantprobs A numeric vector of probabilities with values in [0,1], similar to
#' that in \code{quantile} from the \code{stats} package, producing sample
#' quantiles corresponding to the given probabilities. The default is
#' \code{c(0.05, 0.25, 0.5, 0.75, 0.95)}.
#' @param
#' ask A logical value; If \code{TRUE} (and the \R session is interactive) the
#' user will be prompted before a new output is printed. The default is
#' \code{ask = interactive()}.
#' @param
#' ... Additional arguments, such as \code{digits}, that are passed to the
#' generic \code{summary} function.
#'
#' @return
#' Returns and prints summaries of posterior samples generated by the
#' \code{\link{epiPOMS_mcmc}} inference routine, including the highest posterior
#' density intervals (\code{HPD}), quantiles (\code{quantiles}), effective sample
#' size (\code{ESS}) for each parameter, and the mean (\code{mean_vec}) and
#' covariance matrix (\code{cov_mat}) of all parameters.
#'
#' @details
#' The highest posterior density intervals and effective sample size for each
#' model parameter are computed using the \code{HPDinterval} and
#' \code{effectiveSize} function, respectively, from the \code{coda} package.
#'
#' @author
#' Panayiota Touloupou
#'
#' @seealso
#' \code{\link{epiPOMS_mcmc}} for generating posterior samples of the
#' model parameters and \code{\link{plot.epiPOMSmcmc}} for
#' plotting the outputs of an \sQuote{epiPOMSmcmc} object.
#'
#' @export
summary.epiPOMSmcmc <- function(object, HPDprob = 0.9, quantprobs = c(0.05, 0.25, 0.5, 0.75, 0.95),
    ask = interactive(), ...) {
    
    # Error checks for input arguments
    if (!is(object, "epiPOMSmcmc")) {
        stop("summary.epiPOMSmcmc: The object must be a class of 'epiPOMSmcmc'.", call. = FALSE)
    }
    
    check <- HPDprob
    if (is.null(check)) {
        stop("summary.epiPOMSmcmc: The HPDprob has to be specified.", call. = FALSE)
    } else if ((length(check) != 1) | is.list(check)) {
        stop("summary.epiPOMSmcmc: The HPDprob must be a numeric scalar in the interval (0,1).", 
            call. = FALSE)
    } else if (!is.numeric(check)) {
        stop("summary.epiPOMSmcmc: The HPDprob must be a numeric scalar in the interval (0,1).", 
            call. = FALSE)
    } else if ((check <= 0) | (check >= 1)) {
        stop("summary.epiPOMSmcmc: The HPDprob must be a numeric scalar in the interval (0,1).", 
            call. = FALSE)
    }
    
    check <- quantprobs
    if (is.null(check)) {
        stop("summary.epiPOMSmcmc: The quantprobs has to be specified.", call. = FALSE)
    } else if ((!is.vector(check)) | is.list(check)) {
        stop("summary.epiPOMSmcmc: The quantprobs must be a vector.", call. = FALSE)
    } else if (suppressWarnings(any(is.na(as.numeric(check))))) {
        stop("summary.epiPOMSmcmc: The entries of quantprobs must be between zero and one.", call. = FALSE)
    } else if (any(check < 0) | any(check > 1)) {
        stop("summary.epiPOMSmcmc: The entries of quantprobs must be between zero and one.", call. = FALSE)
    }
    
    check <- ask
    if (is.null(check)) {
        stop("summary.epiPOMSmcmc: The ask has to be specified.", call. = FALSE)
    } else if ((length(check) != 1) | is.list(check)) {
        stop("summary.epiPOMSmcmc: The ask must be logical, either TRUE or FALSE.", call. = FALSE)
    } else if (!is.logical(check) | is.na(check)) {
        stop("summary.epiPOMSmcmc: The ask must be logical, either TRUE or FALSE.", call. = FALSE)
    }
    
    # End of error checks for input arguments
    
    ntypes <- ncol(object$alphamcmc)
    
    if (is.null(object$gammamcmc)) {
        pars <- cbind(object$alphamcmc, object$betamcmc, object$mumcmc, object$deltamcmc, object$numcmc, 
            object$thetamcmc)
        colnames(pars) <- c(sprintf("alpha_%g", 1:ntypes), sprintf("beta_%g", 1:ntypes), sprintf("mu_%g", 
            1:ntypes), "delta", sprintf("nu_%g", 0:ntypes), sprintf("theta_%g", 1:2), "theta_C", 
            "theta_S", "theta_P")
    } else {
        pars <- cbind(object$alphamcmc, object$betamcmc, object$mumcmc, object$deltamcmc, object$gammamcmc, 
            object$numcmc, object$thetamcmc)
        colnames(pars) <- c(sprintf("alpha_%g", 1:ntypes), sprintf("beta_%g", 1:ntypes), sprintf("mu_%g", 
            1:ntypes), "delta", "gamma", sprintf("nu_%g", 0:ntypes), sprintf("theta_%g", 1:2), 
            "theta_C", "theta_S", "theta_P")
    }
    
    if (ask) {
        readline("Press enter to continue")
    }
    
    cat("\n1. Highest posterior density intervals for each parameter:\n\n")
    HPD <- coda::HPDinterval(as.mcmc(pars), prob = HPDprob)
    print(HPD, ...)
    
    if (ask) {
        readline("Press enter to see next output:")
    }
    
    cat("\n2. Quantiles for each parameter:\n\n")
    quantiles <- t(apply(pars, 2, function(x) quantile(x, probs = quantprobs)))
    print(quantiles, ...)
    
    if (ask) {
        readline("Press enter to see next output:")
    }
    
    ESS <- cbind(coda::effectiveSize(as.mcmc(pars)), rep(x = nrow(pars), ncol(pars)))
    colnames(ESS) <- c("ESS", "Sample size")
    cat("\n3. Effective sample size for each parameter:\n\n")
    print(ESS, ...)
    
    if (ask) {
        readline("Press enter to see next output:")
    }
    
    cat("\n4. Mean and covariance matrix of the parameters:\n\n")
    cat("Mean vector:\n\n")
    mean_vec <- apply(pars, 2, mean)
    print(mean_vec, ...)
    
    if (ask) {
        readline("Press enter to see next output:")
    }
    cat("Covariance matrix:\n\n")
    cov_mat <- cov(pars)
    print(cov_mat, ...)
    
    
    output <- list(HPD = HPD, quantiles = quantiles, ESS = ESS, mean_vec = mean_vec, cov_mat = cov_mat)
    
    return(output)
}



